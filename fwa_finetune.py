# -*- coding: utf-8 -*-
"""FWA_FineTune.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eEK_9waPHzNs0ho6kejUBwgCm-mbGYff

# Initializations
"""

!git clone https://github.com/Morteza-24/CVPRW2019_Face_Artifacts.git

!pip install tf-slim
!pip install opencv-python==3.4.18.65
!pip install --upgrade "tensorflow<=2.10"

from google.colab import drive
drive.mount('/content/drive')

!mv CVPRW2019_Face_Artifacts/* ./
!unzip drive/MyDrive/ckpt_res50.zip
!mkdir ckpt_res50
!mv model.* ckpt_res50/
!mkdir train_imgs
!mkdir test_imgs

import os, cv2
import numpy as np

rng = np.random.default_rng()

def sample_frames_from_videos(src, dst, num_frames=5):
  vids = os.listdir(src)
  for vid in vids:
    cap = cv2.VideoCapture(src+vid)
    length = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
    frames = sorted(set(rng.choice(length-2, size=num_frames, replace=False)))
    for frame in frames:
      cap.set(cv2.CAP_PROP_POS_FRAMES, frame)
      _, img = cap.read()
      cv2.imwrite(dst+f'{vid}_{frame}.jpg', img)

sample_frames_from_videos('drive/MyDrive/CELEBDF_V2/Real/', 'test_imgs/rC_')
sample_frames_from_videos('drive/MyDrive/CELEBDF_V2/Fake/', 'test_imgs/fC_')

!cd test_imgs; mv `ls | sort -R | sed -n 1~4p` ../train_imgs/

!ls -1 test_imgs | wc -l;
!ls -1 train_imgs | wc -l;
# ~25%

!mkdir -p test_imgs/real
!mkdir -p test_imgs/fake
!mv test_imgs/rC* test_imgs/real/
!mv test_imgs/fC* test_imgs/fake/

"""# Tests Before Fine-Tuning"""

!python demo.py --input_dir=test_imgs/real > real_results.txt

!python demo.py --input_dir=test_imgs/fake > fake_results.txt

y_true = []
y_pred = []
with open("real_results.txt", "r") as f:
  lines = f.readlines()
  for line in lines:
    if line.startswith("Prob:"):
      prob = float(line.split(" ")[1][:-1])
      y_pred.append(prob)
      y_true.append(0)
with open("fake_results.txt", "r") as f:
  lines = f.readlines()
  for line in lines:
    if line.startswith("Prob:"):
      prob = float(line.split(" ")[1][:-1])
      y_pred.append(prob)
      y_true.append(1)
y_true = np.array(y_true)
y_pred = np.array(y_pred)

import matplotlib.pyplot as plt
from sklearn.metrics import (precision_recall_curve, accuracy_score,
                             confusion_matrix, roc_auc_score, roc_curve,
                             matthews_corrcoef, auc,
                             RocCurveDisplay, PrecisionRecallDisplay, auc)

precision, recall, thresholds = precision_recall_curve(y_true, y_pred)
disp = PrecisionRecallDisplay(precision=precision, recall=recall)
disp.plot()
plt.show()
fscore = (2 * precision * recall) / (precision + recall)
ix = np.argmax(fscore)
print("threshold:", thresholds[ix])
print("f-score:", fscore[ix])
print("precision:", recall[ix])
print("recall:", precision[ix])

print("accuracy:", accuracy_score(y_true, y_pred>thresholds[ix]))

fpr, tpr, thresholds = roc_curve(y_true, y_pred)
roc_auc = auc(fpr, tpr)
display = RocCurveDisplay(fpr=fpr, tpr=tpr, roc_auc=roc_auc)
display.plot()
plt.show()

ix = np.argmax(tpr - fpr)
print("threshold:", thresholds[ix])
print("accuracy:", accuracy_score(y_true, y_pred>thresholds[ix]))
print("MCC:", matthews_corrcoef(y_true, y_pred>thresholds[ix]))

"""# Fine-Tuning"""

import tensorflow.compat.v1 as tf
tf.disable_v2_behavior()
from data_proc_train import DataProcTrain
from resolution_network import ResoNet
from solver import Solver
from easydict import EasyDict as edict
import yaml, numpy as np


cfg_file = 'cfgs/res50.yml'
with open(cfg_file, 'r') as f:
    cfg = edict(yaml.safe_load(f))

data_gen = DataProcTrain(
    face_img_dir="train_imgs",
    cache_path="landmarks.p",
    batch_size=cfg.TRAIN.BATCH_SIZE,
    is_shuffle=True)

tfconfig = tf.ConfigProto(allow_soft_placement=True)
tfconfig.gpu_options.allow_growth=True
cfg.TRAIN.DECAY_STEP = data_gen.batch_num
epoch = cfg.TRAIN.NUM_EPOCH

with tf.compat.v1.Session() as sess:
    reso_net = ResoNet(cfg=cfg, is_train=True)
    reso_net.build()
    solver = Solver(sess=sess, cfg=cfg, net=reso_net)
    solver.init()
    count = 0
    for epoch_id in range(epoch):
        for i in range(data_gen.batch_num):
            data = data_gen.get_batch(i, resize=cfg.IMG_SIZE[:2])
            images = data['images']
            labels = data['images_label']
            # ims_tmp = vis_im(images, 'tmp/vis.jpg')
            # summary, prob, net_loss, total_loss, weights = solver.train(images, labels)
            summary, prob, net_loss, total_loss = solver.train(images, labels)
            pred_labels = np.argmax(prob, axis=1)
            print('====================================')
            print('Net loss: {}'.format(net_loss))
            print('Total loss: {}'.format(total_loss))
            print('Real label: {}'.format(np.array(labels)))
            print('Pred label: {}'.format(pred_labels))
            # print('Neg hard mining: {}'.format(weights))
            print('epoch: {}, batch_idx: {}'.format(epoch_id, i))
            # if count % 100 == 0:
            #     solver.writer.add_summary(summary, count)
            # count += 1

        if epoch_id % 2 == 0:
            solver.save(epoch_id)

"""# Tests After Fine-Tuning"""

# Change model name in cfg file

!python demo.py --input_dir=test_imgs/real > real_results.txt

!python demo.py --input_dir=test_imgs/fake > fake_results.txt

y_true = []
y_pred = []
with open("real_results.txt", "r") as f:
  lines = f.readlines()
  for line in lines:
    if line.startswith("Prob:"):
      prob = float(line.split(" ")[1][:-1])
      y_pred.append(prob)
      y_true.append(0)
with open("fake_results.txt", "r") as f:
  lines = f.readlines()
  for line in lines:
    if line.startswith("Prob:"):
      prob = float(line.split(" ")[1][:-1])
      y_pred.append(prob)
      y_true.append(1)
y_true = np.array(y_true)
y_pred = np.array(y_pred)

import matplotlib.pyplot as plt
from sklearn.metrics import (precision_recall_curve, accuracy_score,
                             confusion_matrix, roc_auc_score, roc_curve,
                             matthews_corrcoef, auc,
                             RocCurveDisplay, PrecisionRecallDisplay, auc)

precision, recall, thresholds = precision_recall_curve(y_true, y_pred)
disp = PrecisionRecallDisplay(precision=precision, recall=recall)
disp.plot()
plt.show()
fscore = (2 * precision * recall) / (precision + recall)
ix = np.argmax(fscore)
print("threshold:", thresholds[ix])
print("f-score:", fscore[ix])
print("precision:", recall[ix])
print("recall:", precision[ix])

print("accuracy:", accuracy_score(y_true, y_pred>thresholds[ix]))

fpr, tpr, thresholds = roc_curve(y_true, y_pred)
roc_auc = auc(fpr, tpr)
display = RocCurveDisplay(fpr=fpr, tpr=tpr, roc_auc=roc_auc)
display.plot()
plt.show()

ix = np.argmax(tpr - fpr)
print("threshold:", thresholds[ix])
print("accuracy:", accuracy_score(y_true, y_pred>thresholds[ix]))
print("MCC:", matthews_corrcoef(y_true, y_pred>thresholds[ix]))

